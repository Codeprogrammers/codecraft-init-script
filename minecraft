#!/bin/bash
# /etc/init.d/minecraft
# version 0.3.12 2011-12-21 (YYYY-MM-DD)

### BEGIN INIT INFO
# Provides:   minecraft
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:   $network
# Should-Stop:    $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Short-Description:    Minecraft server
# Description:    Starts the minecraft server
### END INIT INFO


#Settings
USERNAME='daniel'
GROUPNAME='daniel'
SCREEN_NAME='codecraft'
BUILD='b1597'
SERVICE='craftbukkit.jar'
INVOCATION="java -Xms512M -Xmx1024M -jar craftbukkit.jar"
RAMDISK='true'

#File Paths
ROOT_PATH="/mnt/codecraft"
WORLD_PATH="$ROOT_PATH/worlds"
MC_PATH="$ROOT_PATH/servers/$BUILD"
RD_PATH="$ROOT_PATH/ramdisk"
ROOT_BACKUPPATH="$ROOT_PATH/archives"
WORLD_BACKUPPATH="$ROOT_BACKUPPATH/worlds"
SERVER_BACKUPPATH="ROOT_BACKUPPATH/servers"
RD_BACKUPPATH="$ROOT_BACKUPPATH/ramdisk"

#Messages (sent to minecraft server console with "say" command)
SAVE_OFF_MSG='Server going readonly...'
SAVE_ON_MSG='Server going read-write...'
BACKUP_START_MSG='SERVER BACKUP STARTING'
BACKUP_DONE_MSG='SERVER BACKUP COMPLETE'
BACKUP_FAIL_MSG='SERVER BACKUP FAILED'
STOP_MSG='SERVER SHUTTING DOWN IN 15 SECONDS'
RESTART_MSG='SERVER GOING FOR RESTART'

############################[ Script Start]#############################

#Grabbing world name from $MC_PATH/server.properties
WORLD_NAME=$(cat $MC_PATH/server.properties | fgrep 'level-name=' | sed -e s/.*level-name=//)

#Run commands as the user defined in the $USERNAME variable
ME=`whoami`
as_user() {
  if [ $ME == $USERNAME ]
  then
    bash -c "$1"
  else
    su - $USERNAME -c "$1"
  fi
}

#Starts the service
mc_start() {
  if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
  then echo "Tried to start but $SERVICE was already running!"
  else echo "$SERVICE was not running... starting."

    if [ $RAMDISK == 'true' ]
    then
      if mount -l -t tmpfs | grep $RD_PATH > /dev/null
      then echo "Ramdisk Loaded"
      else echo "Loading Ramdisk"
        mcrd_mount
        mcrd_load
      fi
    fi

    as_user "cd $MC_PATH && screen -dmS $SCREEN_NAME $INVOCATION" ; sleep 7

    #Check to see if the service started successfully
    if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
    then echo "$SERVICE is now running."
    else echo "Could not start $SERVICE."

      if [ $RAMDISK == 'true' ]
      then
        if mount -l -t tmpfs | grep $RD_PATH > /dev/null
        then echo "Unloading Ramdisk."

          mcrd_unload
          mcrd_unmount

        else echo "Ramdisk already unloaded!"
        fi
      fi

    fi
  fi
}

#Stops the service
mc_stop() {
  if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
  then echo "$SERVICE is running... stopping."

    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $STOP_MSG\"\015'" ; sleep 5   # Tell the users that the server is stopping, Wait 5 seconds
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"save-all\"\015'" ; sleep 10       # Save changes to the worlds, Wait 10 seconds
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"stop\"\015'" ; sleep 3            # Stop the server, Wait 3 seconds

  else echo "$SERVICE was not running."
  fi

  if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
  then echo "$SERVICE could not be shut down... still running."
  else echo "$SERVICE is shut down."
  fi
}

#Disables automatic saving and saves all current changes to the worlds
mc_saveoff() {
  if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
  then echo "$SERVICE is running... suspending saves"

    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $SAVE_OFF_MSG\"\015'"   # Tell the users that saving is turning off
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"save-off\"\015'"            # Turn saving off
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"save-all\"\015'"            # Save changes to the worlds
    sync ; sleep 5                                                                    # Write changes to disk, Wait 5 seconds

  else echo "$SERVICE was not running. Not suspending saves."
  fi
}

#Enables automatic saving
mc_saveon() {
  if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
  then echo "$SERVICE is running... re-enabling saves"

    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"save-on\"\015'"            # Turn auto-saving on
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $SAVE_ON_MSG\"\015'"   # Tell the users that saving is now on

  else echo "$SERVICE was not running. Not resuming saves."
  fi
}

#Backup the current world files
mc_world_backup() {

  if [ $RAMDISK == 'true' ] && mount -l -t tmpfs | grep $RD_PATH > /dev/null
  then WORLD_PATH="$RD_PATH/worlds"
  fi

  echo "Backing Up Worlds"
  cd $WORLD_BACKUPPATH

  # Check for directories with the current datestamp
  if ls | grep $DATE > /dev/null
  then
    bu_date=$(ls -1r --group-directories-first | head -n1)
  else
    as_user "mkdir $DATE"
    bu_date=$(ls -1r --group-directories-first | head -n1)
  fi

  cd $bu_date   # cd into most recently created directory

  # Check for directories with the curent timestamp.
  if ls | grep $TIME > /dev/null
  then
    bu_time=$(ls -1r --group-directories-first | head -n1 | head -c5)   # Set $bu_time to the name of the newest directory
    bu_time="$bu_time"_`date "+%S"`                                     # Appened the current seconds time to $bu_time
    as_user "mkdir $bu_time"                                            # Make a directory with the name contained in $bu_time
    as_user "cp -a $WORLD_PATH/* $bu_time"                              # Copy all data from the $WORLD_PATH directory to the $bu_time directory
  else
    as_user "mkdir $TIME"                                               # Make a directory with the current timestamp as the name
    bu_time=$(ls -1r --group-directories-first | head -n1)              # Set the $bu_time variable to the newest directory
    as_user "cp -a $WORLD_PATH/* $bu_time"                              # Copy all data from the $WORLD_PATH directory to the $bu_time directory
  fi
}

#Check the integrity of the backup
mc_world_backup_cksum() {
  echo "Running a Checksum of the Backups"
  cd $WORLD_BACKUPPATH/..

  if [ -d "chksum" ]
  then cd chksum

    if [ -d "worlds" ]
    then
      rm -rf "worlds"
      as_user "mkdir worlds"
    else
      as_user "mkdir worlds"
    fi

    if [ -d "worlds_backup" ]
    then
      rm -rf "worlds_backup"
      as_user "mkdir worlds_backup"
    else
      as_user "mkdir worlds_backup"
    fi

  else
    as_user "mkdir chksum" ; cd chksum
    as_user "mkdir worlds ; mkdir worlds_backup"
  fi

  cd $WORLD_PATH
  as_user "tar -cf worlds.tar *"
  as_user "mv worlds.tar $WORLD_BACKUPPATH/../chksum/worlds"

  cd $WORLD_BACKUPPATH/$bu_date/$bu_time
  as_user "tar -cf worlds.tar *"
  as_user "mv worlds.tar $WORLD_BACKUPPATH/../chksum/worlds_backup"

  cd $WORLD_BACKUPPATH/../chksum
  WORLD_checksum=$(ls worlds | cksum)           # Set $WORLD_checksum to the value of the checksum of the current worlds' tarball
  BACKUP_checksum=$(ls worlds_backup | cksum)   # Set $BACKUP_checksum to the value of the checksum of the newest backup's tarball


  # Compare the values of the checksums
  if [ "$WORLD_checksum" = "$BACKUP_checksum" ]
  then
    echo "Backup Complete"
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $BACKUP_DONE_MSG\"\015'"
  else
    echo "Backup failed! The source and target contents do not match!"
    echo "Worlds: $WORLD_checksum" ; echo "Backup: $BACKUP_checksum"
    as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $BACKUP_FAIL_MSG\"\015'"
  fi
}

# Mount the Ramdisk at $RD_PATH
mcrd_mount() {
  if mount -l -t tmpfs | grep $RD_PATH > /dev/null
  then echo "Ramdisk already mounted"
  else echo "Mounting Ramdisk at $RD_PATH"
  
    if [ ! -d $RD_PATH ]
    then echo "$RD_PATH does not exist!" ; exit 1
    fi

    mount -t tmpfs -o size=$RD_SIZE tmpfs $RD_PATH
    sleep 3
    chown $USERNAME:$GROUPNAME $RD_PATH

    if mount -l -t tmpfs | grep $RD_PATH > /dev/null
    then echo "Ramdisk mounted at $RD_PATH"
    else echo "Could not mount Ramdisk. Does $RD_PATH exist?"
    fi
  fi
}

mcrd_unmount() {
  if mount -l -t tmpfs | grep $RD_PATH > /dev/null
  then echo "Ramdisk mounted at $RD_PATH.... unmounting"

    umount $RD_PATH
    sleep 3

  else echo "Ramdisk was not mounted at $RD_PATH"
  fi

  if mount -l -t tmpfs | grep $RD_PATH > /dev/null
  then echo "Could not unmount ramdisk at $RD_PATH"
  else echo "Ramdisk unmounted"
  fi
}

mcrd_load() {
RUN_DIR=$(dirname $0)

  if mount -l -t tmpfs | grep $RD_PATH > /dev/null
  then

    cd $RD_PATH
    as_user "mkdir worlds"

    if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null   # Is service running?
    then echo "Tried to start but $SERVICE was already running!"              # Instance exists, tell the user
    else echo "$SERVICE was not running... loading Ramdisk."                  # Instance does not exist, tell user we are going to start it

      if [ ! -d $WORLD_PATH/$WORLD_NAME ]                                     # Checking for the  existance of a world using the name defined in server.properties
      then echo "$WORLD_NAME is not in $WORLD_PATH!"                          # If no world exists, tell the user
      else cd $WORLD_PATH                                                     # If the world does exist, cd to $WORLD_PATH

        for dir in *                                                          # For each folder in WORLD_PATH,
        do

          if [ ! -d "$RD_PATH/worlds/$dir" ]                                  # We are going to make sure it does not reside on the RAMDISK
          then javwc=`expr match "$dir" '.*[0-9]'`                            # Expression to filter out the world backups (ignore something ending with a number)

            echo `pwd`

            if [ -d "$dir" ] && [ -f "$dir/level.dat" ] && [ $javwc -eq 0 ]   # Make sure it is a directory, and that it has a level.dat file in it, and the it IS NOT a backup
            then as_user "cp -R $WORLD_PATH/$dir $RD_PATH/worlds"             # Copy the world from $WORLD_PATH to $RD_PATH

              if [ -d "$MC_PATH/$dir" ]                                       # Are there folders or symlinks already in $MC_PATH?
              then as_user "mv $MC_PATH/$dir $MC_PATH/$dir.old"               # Rename them with the suffix ".old"
              fi

              as_user "ln -s $RD_PATH/worlds/$dir $MC_PATH/$dir"              # Setup the symlinks to the worlds on the RAMDISK
            fi
          fi
        done
      fi                                                                      # Close if statement "world exist?"
    fi                                                                        # Close if statement "running?"

  else echo "Cound not start $SERVICE, ramdisk could not be mounted"
  fi                                                                          # Close if statement "RAMDISK mounted?"
}

mcrd_unload() {
  if mount -l -t tmpfs | grep $RD_PATH > /dev/null                            # Check if the Ramdisk is mounted
  then

    if [ ! -d $RD_PATH/worlds/$WORLD_NAME ]                                   # Check if $WORLD_NAME (whatevere it was named in server.properties) exists in $RD_PATH
    then echo "Nothing in $RD_PATH to backup!"                                # Not found! Warn user!
    else echo "Saving ramdisk to disk."                                       # Else we have found something and will continue with the regime, warn user we are beginning

      cd $RD_PATH                                                             # Make sure we are in the $RD_PATH for the next series of commands
      filedate=$(date +"-%F-%H.%M")                                           # Set up our datestamp here.

      for dir in *                                                            # For each directory inside $RD_PATH, we are going to perform the following series of commands
      do

        if [ -d "$dir" ] && [ -f "$dir/level.dat" ]                           # Make sure it is a directory and verify itis a world by looking for "level.dat" inside of it.
        then

          if [ -d "$WORLD_PATH/$dir" ]                                        # Now we check to see if the world folder we found already exists in the $WORLD_PATH
          then
            echo "Moving "$WORLD_PATH\/$dir" to "$WORLD_PATH\/$dir$filedate   # We tell the user what we are going to do
            as_user "mv "$WORLD_PATH\/$dir"/ "$WORLD_PATH\/$dir$filedate      # Then rename the found folder with a datestamp on the end of it's name
          fi

          echo "$dir being copied to disk"                                    # Tell the user we are copying the RAMDISK
          as_user "cp -R $RD_PATH/$dir $WORLD_PATH/"                          # Copy the world from $RD_PATH to $WORLD_PATH

        else echo "Nothing copied from ramdisk."                              # If no world folders are found, we tell the user.
        fi

      done                                                                    # END for loop (directory inside $RD_PATH)
      as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"save-on\"\015'"   # Send "save-on" to the instance
    fi

  else echo "Nothing to save, Ramdisk not mounted at $RD_PATH"                # Service not running, nothing to save
  fi
}

mcrd_full_backup() {
  if mount -l -t tmpfs | grep $RD_PATH > /dev/null
  then

    if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
    then echo "$SERVICE is running, backing up Ramdisk at $RD_PATH"

      mc_saveoff
      as_user "cp -R $RD_PATH $RD_BACKUPPATH"
      mc_saveon

    else echo "Backing up Ramdisk at $RD_PATH"
      as_user "cp -R $RD_PATH $RD_BACKUPPATH"
    fi

  else echo "Ramdisk not mounted at $RD_PATH !"
  fi
}

#Start-Stop here
case "$1" in
  start)
    mc_start
    ;;
  stop)
    mc_stop
    if [ $RAMDISK == 'true' ]
    then
      mcrd_unload
      mcrd_unmount
    fi
    ;;
  restart)
    if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
    then
      as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $RESTART_MSG\"\015'"
      mc_stop
      mc_start
    else
      mc_start
    fi
    ;;
  worldbackup)
    DATE=$(date "+%Y-%m-%d")
    TIME=$(date "+%H-%M")
    if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
    then
      as_user "screen -p 0 -S $SCREEN_NAME -X eval 'stuff \"say $BACKUP_START_MSG\"\015'"
    fi

    mc_saveoff
    mc_world_backup
    mc_world_backup_cksum
    mc_saveon
    ;;
  status)
    if ps ax | grep -v grep | grep -v -i SCREEN | grep $SERVICE > /dev/null
    then echo "$SERVICE is running."
    else echo "$SERVICE is not running."
    fi
    ;;
  rd2disk)
    # Backup RD contents
    
    DATE=$(date "+%Y-%m-%d")
    TIME=$(date "+%H-%M")
    mcrd_full_backup
    ;;

  *)
  echo "Usage: /etc/init.d/minecraft {start|stop|restart|status|rd2disk|worldbackup}"
  exit 1
  ;;
esac

exit 0
